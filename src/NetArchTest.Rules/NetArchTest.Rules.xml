<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetArchTest.Rules</name>
    </assembly>
    <members>
        <member name="T:NetArchTest.Rules.ConditionList">
            <summary>
            A set of conditions and types that have have conjunctions (i.e. "and", "or") and executors (i.e. Types(), GetResult()) applied to them.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.ConditionList._types">
            <summary> A list of types that conditions can be applied to. </summary>
        </member>
        <member name="F:NetArchTest.Rules.ConditionList._sequence">
            <summary> The sequence of conditions that is applied to the type of list. </summary>
        </member>
        <member name="F:NetArchTest.Rules.ConditionList._should">
            <summary> Determines the polarity of the selection, i.e. "should" or "should not". </summary>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Boolean,NetArchTest.Rules.FunctionSequence)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.ConditionList"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.GetResult">
            <summary>
            Returns an indication of whether all the selected types satisfy the conditions.
            </summary>
            <returns>An indication of whether the conditions are true, along with a list of types failing the check if they are not.</returns>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.Count">
            <summary>
            Returns the number of types that satisfy the conditions.
            </summary>
            <returns>A list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.GetTypes">
            <summary>
            Returns the list of types that satisfy the conditions.
            </summary>
            <returns>A list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.And">
            <summary>
            Specifies that any subsequent condition should be treated as an "and" condition.
            </summary>
            <returns>An set of conditions that can be applied to a list of classes.</returns>
            <remarks>And() has higher priority than Or() and it is computed first.</remarks>
        </member>
        <member name="M:NetArchTest.Rules.ConditionList.Or">
            <summary>
            Specifies that any subsequent conditions should be treated as part of an "or" condition.
            </summary>
            <returns>An set of conditions that can be applied to a list of classes.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Conditions">
            <summary>
            A set of conditions that can be applied to a list of types.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Conditions._types">
            <summary> A list of types that conditions can be applied to. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Conditions._sequence">
            <summary> The sequence of conditions that is applied to the type of list. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Conditions._should">
            <summary> Determines the polarity of the selection, i.e. "should" or "should not". </summary>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Conditions"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Boolean,NetArchTest.Rules.FunctionSequence)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Conditions"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveName(System.String)">
            <summary>
            Selects types that have a specific name.
            </summary>
            <param name="name">The name of the class to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveName(System.String)">
            <summary>
            Selects types that do not have a particular name.
            </summary>
            <param name="name">The name of the class to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveNameMatching(System.String)">
            <summary>
            Selects types according to a regular expression matching their name.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveNameMatching(System.String)">
            <summary>
            Selects types according to a regular expression that does not match their name.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveNameStartingWith(System.String)">
            <summary>
            Selects types whose names start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveNameStartingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveNameStartingWith(System.String)">
            <summary>
            Selects types whose names do not start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveNameStartingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names do not start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveNameEndingWith(System.String)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveNameEndingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveNameEndingWith(System.String)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveNameEndingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveCustomAttribute(System.Type)">
            <summary>
            Selects types are decorated with a specific custom attribut.
            </summary>
            <param name="attribute">The attribute to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveCustomAttribute(System.Type)">
            <summary>
            Selects types that are not decorated with a specific custom attribute.
            </summary>
            <param name="attribute">The attribute to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveCustomAttributeOrInherit(System.Type)">
            <summary>
            Selects types that are decorated with a specific custom attribute or derived one.
            </summary>
            <param name="attribute">The base attribute to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveCustomAttributeOrInherit(System.Type)">
            <summary>
            Selects types are not decorated with a specific custom attribute or derived one.
            </summary>
            <param name="attribute">The base attribute to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.Inherit(System.Type)">
            <summary>
            Selects types that inherit a particular type.
            </summary>
            <param name="type">The type to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotInherit(System.Type)">
            <summary>
            Selects types that do not inherit a particular type.
            </summary>
            <param name="type">The type to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ImplementInterface(System.Type)">
            <summary>
            Selects types that implement a particular interface.
            </summary>
            <param name="interfaceType">The interface type to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotImplementInterface(System.Type)">
            <summary>
            Selects types that do not implement a particular interface.
            </summary>
            <param name="interfaceType">The interface type to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeAbstract">
            <summary>
            Selects types that are marked as abstract.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeAbstract">
            <summary>
            Selects types that are not marked as abstract.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeClasses">
            <summary>
            Selects types that are classes.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeClasses">
            <summary>
            Selects types that are not classes.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeGeneric">
            <summary>
            Selects types that have generic parameters.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeGeneric">
            <summary>
            Selects types that do not have generic parameters.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeInterfaces">
            <summary>
            Selects types that are interfaces.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeInterfaces">
            <summary>
            Selects types that are not interfaces.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeNested">
            <summary>
            Selects types that are nested.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeNestedPublic">
            <summary>
            Selects types that are nested and public.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeNestedPrivate">
            <summary>
            Selects types that are nested and private.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeNested">
            <summary>
            Selects types that are not nested.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeNestedPublic">
            <summary>
            Selects types that are not nested and public.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeNestedPrivate">
            <summary>
            Selects types that are not nested and private.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BePublic">
            <summary>
            Selects types that are have public scope.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBePublic">
            <summary>
            Selects types that do not have public scope.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeSealed">
            <summary>
            Selects types according that are marked as sealed.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotBeSealed">
            <summary>
            Selects types according that are not marked as sealed.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeImmutable">
            <summary>
            Selects types that are immutable.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.BeMutable">
            <summary>
            Selects types that are mutable.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.OnlyHaveNullableMembers">
            <summary>
            Selects types according to whether they have nullable members.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveSomeNonNullableMembers">
            <summary>
            Selects types according to whether they have nullable members.
            </summary>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ResideInNamespace(System.String)">
            <summary>
            Selects types that reside in a particular namespace.
            </summary>
            <param name="name">The namespace to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotResideInNamespace(System.String)">
            <summary>
            Selects types that do not reside in a particular namespace.
            </summary>
            <param name="name">The namespace to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ResideInNamespaceMatching(System.String)">
            <summary>
            Selects types that reside in a namespace matching a regular expression.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotResideInNamespaceMatching(System.String)">
            <summary>
            Selects types that do not reside in a namespace matching a regular expression.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ResideInNamespaceStartingWith(System.String)">
            <summary>
            Selects types whose namespaces start with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotResideInNamespaceStartingWith(System.String)">
            <summary>
            Selects types whose namespaces start with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ResideInNamespaceEndingWith(System.String)">
            <summary>
            Selects types whose namespaces end with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotResideInNamespaceEndingWith(System.String)">
            <summary>
            Selects types whose namespaces end with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.ResideInNamespaceContaining(System.String)">
            <summary>
            Selects types whose namespaces contain a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotResideInNamespaceContaining(System.String)">
            <summary>
            Selects types whose namespaces contain a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveDependencyOn(System.String)">
            <summary>
            Selects types that have a dependency on a particular type.
            </summary>
            <param name="dependency">The dependency to match against. This can be a namespace or a specific type.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveDependencyOnAny(System.String[])">
            <summary>
            Selects types that have a dependency on any of the supplied types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveDependencyOnAll(System.String[])">
            <summary>
            Selects types that have a dependency on all of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.OnlyHaveDependenciesOn(System.String[])">
            <summary>
            Selects types that have a dependency on any of the supplied types and cannot have any other dependency. 
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveDependencyOn(System.String)">
            <summary>
            Selects types that do not have a dependency on a particular type.
            </summary>
            <param name="dependency">The dependency type to match against. This can be a namespace or a specific type.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveDependencyOnAny(System.String[])">
            <summary>
            Selects types that do not have a dependency on any of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.NotHaveDependencyOnAll(System.String[])">
            <summary>
            Selects types that do not have a dependency on all of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.HaveDependenciesOtherThan(System.String[])">
            <summary>
            Selects types that have a dependency other than any of the given dependencies.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Conditions.MeetCustomRule(NetArchTest.Rules.ICustomRule)">
            <summary>
            Selects types that meet a custom rule.
            </summary>
            <param name="rule">An instance of the custom rule.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="F:NetArchTest.Rules.Dependencies.DataStructures.CachedNamespaceTree._searchTree">
            <summary> The list of dependencies being searched for. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Dependencies.DataStructures.CachedNamespaceTree._cachedAnswersFromSearchTree">
            <summary>
            Searching search tree is costly (it requires a lot of operations on strings like SubString, IndexOf).
            For a given type we always get the same answer, so let us cache what search tree returns.
            </summary>        
        </member>
        <member name="T:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree">
            <summary>
            Holds tree structure of full names; child nodes of each parent are indexed for optimal time of search.
            </summary>
            <example>
            The sequence {"System.Linq", "System.Object", "System", "System.Collections.Generic", "NetArchTest.TestStructure.Dependencies.Examples"}
            produces the tree
            ""
            |- "NetArchTest"
            |  |- "TestStructure"
            |     |- "Dependencies"
            |        |- "Examples" (terminated)
            |
            |- "System" (terminated)
               |- "Collections"
               |  |- "Generic" (terminated)
               |
               |- "Linq" (terminated)
               |- "Object" (terminated)
            </example>
            <remarks>
            In the example above the flag "terminated" means that marked name is presented in the sequence the tree is built for.
            Despite of the fact that the namespace "System" takes over its descendants "Linq", "Object" and "Collections.Generic"
            all of them are presented in the tree. For dependency search it provides the same results as original implementation
            based on the String.StartsWith(...) does.
            </remarks>
        </member>
        <member name="P:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Node.Nodes">
            <summary> Maps child namespace to its root node. </summary>
        </member>
        <member name="P:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Node.FullName">
            <summary>Returns full path from root to terminated node. Only available on terminated node.</summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Node.GetOrAddNode(System.String)">
            <summary>
            Adds new child node with given name or returns existing one.
            </summary>
            <param name="name">Name of child node.</param>
            <returns>Child node with given name.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Node.TryGetNode(System.String,NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Node@)">
            <summary>
            Checks whether child node with given name exists and returns it.
            </summary>
            <param name="name">Name of child node of interest.</param>
            <param name="node">Child node with given name, if it exists; otherwise, null.</param>
            <returns>True, if child node with given name exists; otherwise, false.</returns>
        </member>
        <member name="F:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree._root">
            <summary> Holds the root for the namespace tree. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.#ctor(System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Initially fills the tree with given names.
            </summary>
            <param name="fullNames">Sequence of full names.</param>
            <param name="parseNames">if names should be parsed by mono parser</param>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.Add(System.String,System.Boolean)">
            <summary>
            Splits full name into subnamespaces and adds corresponding nodes to the tree.
            </summary>
            <param name="fullName">Can be empty, but not null.</param>
            <param name="parseNames">if names should be parsed by mono parser</param>
        </member>
        <member name="P:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.TerminatedNodesCount">
            <summary> Count of terminated nodes in the tree. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.GetAllMatchingNames(System.String)">
            <summary>
            Retrieves the sequence of all matching names for given full name.
            A name matches some full name, if its node is terminated and whole path from tree root to that node
            builds the chain of namespaces in the full name.
            </summary>
            <param name="fullName">Full name to search matching names for.</param>
            <returns>Sequence of all matching names.</returns>
            <example>
            If the tree contains "System.Collections" and "System.Collections.IList", both are returned
            for the full name "System.Collections.IList".
            </example>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree.GetTokens(Mono.Cecil.TypeReference)">
            <summary>
            Recursively extracts every part from type full name
            </summary>      
        </member>
        <member name="T:NetArchTest.Rules.Dependencies.DataStructures.TypeReferenceTree`1">
            <summary>
            Similar tree to <see cref="T:NetArchTest.Rules.Dependencies.DataStructures.NamespaceTree"/>, but this is aware of the structure of type full name,
            which allows traversing tree without allocating new strings.
            </summary>   
        </member>
        <member name="T:NetArchTest.Rules.Dependencies.DependencySearch">
            <summary>
            Finds dependencies within a given set of types.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DependencySearch.FindTypesThatHaveDependencyOnAny(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types that have a dependency on any item in the given list of dependencies.
            </summary>
            <param name="input">The set of type definitions to search.</param>
            <param name="dependencies">The set of dependencies to look for.</param>
            <returns>A list of found types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DependencySearch.FindTypesThatHaveDependencyOnAll(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types that have a dependency on every item in the given list of dependencies.
            </summary>
            <param name="input">The set of type definitions to search.</param>
            <param name="dependencies">The set of dependencies to look for.</param>
            <returns>A list of found types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DependencySearch.FindTypesThatOnlyHaveDependenciesOnAnyOrNone(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types that may have a dependency on any item in the given list of dependencies, but cannot have a dependency that is not in the list.
            </summary>
            <param name="input">The set of type definitions to search.</param>
            <param name="dependencies">The set of dependencies to look for.</param>
            <returns>A list of found types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DependencySearch.FindTypesThatOnlyHaveDependenciesOnAny(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types that have a dependency on any item in the given list of dependencies, but cannot have a dependency that is not in the list.
            </summary>
            <param name="input">The set of type definitions to search.</param>
            <param name="dependencies">The set of dependencies to look for.</param>
            <returns>A list of found types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.DependencySearch.FindTypesThatOnlyOnlyHaveDependenciesOnAll(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types that have a dependency on every item in the given list of dependencies, but cannot have a dependency that is not in the list.
            </summary>
            <param name="input">The set of type definitions to search.</param>
            <param name="dependencies">The set of dependencies to look for.</param>
            <returns>A list of found types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.TypeDefinitionCheckingContext.CheckType(Mono.Cecil.TypeDefinition)">
            <summary>
            Finds matching dependencies for a given type by walking through the type.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.TypeDefinitionCheckingContext.CheckTypeReference(Mono.Cecil.TypeReference)">
            <summary>
            Recursively checks every array, generic or not type reference
            <example>
            for closed generic : List{Tuple{Task{int}, int}}
            it will check: List{Tuple{Task{int}, int}}, Tuple{Task{int}, int}, Task{int}, int, int
            for open generic : List{T}
            only List will be checked, T as a generic parameter will be skipped
            for arrays: int[][]
            it will check : int[][], int[], int
            </example>         
            </summary>      
        </member>
        <member name="T:NetArchTest.Rules.Dependencies.TypeDefinitionCheckingResult">
            <summary>
            Manages the results of dependency search.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Dependencies.TypeDefinitionCheckingResult._foundDependencies">
            <summary> The list of dependencies that have been found in the search.</summary>
        </member>
        <member name="M:NetArchTest.Rules.Dependencies.TypeDefinitionCheckingResult.CanWeSkipFurtherSearch">
            <summary>
            If we already know the final answer to the question if type was found,
            doing another search will not change the result
            </summary>     
        </member>
        <member name="T:NetArchTest.Rules.Extensions.FieldDefinitionExtensions">
            <summary>
            Extensions for the <see cref="T:Mono.Cecil.FieldDefinition"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.FieldDefinitionExtensions.IsReadonly(Mono.Cecil.FieldDefinition)">
            <summary>
            Tests whether a field is readonly
            </summary>
            <param name="fieldDefinition">The field to test.</param>
            <returns>An indication of whether the field is readonly.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.FieldDefinitionExtensions.IsNullable(Mono.Cecil.FieldDefinition)">
            <summary>
            Tests whether a field is nullable
            </summary>
            <param name="fieldDefinition">The field to test.</param>
            <returns>An indication of whether the field is nullable.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Extensions.PropertyDefinitionExtensions">
            <summary>
            Extensions for the <see cref="T:Mono.Cecil.PropertyDefinition"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.PropertyDefinitionExtensions.IsReadonly(Mono.Cecil.PropertyDefinition)">
            <summary>
            Tests whether a property is readonly
            </summary>
            <param name="propertyDefinition">The property to test.</param>
            <returns>An indication of whether the property is readonly.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.PropertyDefinitionExtensions.IsNullable(Mono.Cecil.PropertyDefinition)">
            <summary>
            Tests whether a property is nullable
            </summary>
            <param name="propertyDefinition">The property to test.</param>
            <returns>An indication of whether the property is nullable.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Extensions.TypeDefinitionExtensions">
            <summary>
            Extensions for the <see cref="T:Mono.Cecil.TypeDefinition"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.IsSubclassOf(Mono.Cecil.TypeDefinition,Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether one class inherits from another.
            </summary>
            <param name="child">The class that is inheriting from the parent.</param>
            <param name="parent">The parent that is inherited.</param>
            <returns>An indication of whether the child inherits from the parent.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.IsFromSameAssemblyAs(Mono.Cecil.TypeDefinition,Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether two type definitions are from the same assembly.
            The comparison is based on the full assembly names.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>An indication of whether the both types are from the same assembly.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.IsSameTypeAs(Mono.Cecil.TypeDefinition,Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether the provided types are the same type.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>An indication of whether the types are the same.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.EnumerateBaseClasses(Mono.Cecil.TypeDefinition)">
            <summary>
            Enumerate the base classes throughout the chain of inheritence.
            </summary>
            <param name="classType">The class to enumerate.</param>
            <returns>The enumeration of base classes.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.ToType(Mono.Cecil.TypeDefinition)">
            <summary>
            Convert the definition to a <see cref="T:System.Type"/> object instance.
            </summary>
            <param name="typeDefinition">The type definition to convert.</param>
            <returns>The equivalent <see cref="T:System.Type"/> object instance.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.IsImmutable(Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether a class is immutable, i.e. all public fields are readonly and properties have no set method
            </summary>
            <param name="typeDefinition">The class to test.</param>
            <returns>An indication of whether the type is immutable</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.HasNullableMembers(Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether a Type has any memebers that are non-nullable value types
            </summary>
            <param name="typeDefinition">The class to test.</param>
            <returns>An indication of whether the type has any memebers that are non-nullable value types</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeDefinitionExtensions.GetNamespace(Mono.Cecil.TypeDefinition)">
            <summary>
            Returns namespace of the given type, if the type is nested, namespace of containing type is returned instead
            </summary>        
            <remarks>
            For nested classes this will take the name of the declaring class. See https://github.com/BenMorris/NetArchTest/issues/73
            </remarks>
        </member>
        <member name="T:NetArchTest.Rules.Extensions.TypeExtensions">
            <summary>
            Extensions for the <see cref="T:System.Type"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeExtensions.ToTypeDefinition(System.Type)">
            <summary>
            Converts the value to a <see cref="T:Mono.Cecil.TypeDefinition"/> instance.
            </summary>
            <param name="type">The type to convert.</param>
            <returns>The converted value.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeReferenceExtensions.IsNullable(Mono.Cecil.TypeReference)">
            <summary>
            Tests whether a Type is a non-nullable value type
            </summary>
            <param name="typeReference">The class to test.</param>
            <returns>An indication of whether the type has any memebers that are non-nullable value types</returns>
        </member>
        <member name="M:NetArchTest.Rules.Extensions.TypeReferenceExtensions.GetNamespace(Mono.Cecil.TypeReference)">
            <summary>
            Returns namespace of the given type, if the type is nested, namespace of containing type is returned instead
            </summary>        
        </member>
        <member name="T:NetArchTest.Rules.FunctionDelegates">
            <summary>
            Defines the various functions that can be applied to a collection of types.
            </summary>
            <remarks>
            These are used by both predicates and conditions so warrant a common definition.
            </remarks>
        </member>
        <member name="T:NetArchTest.Rules.FunctionDelegates.FunctionDelegate`1">
            <summary> The base delegate type used by every function. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveName">
            <summary> Function for finding a specific type name. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveNameMatching">
            <summary> Function for matching a type name using a regular expression. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveNameStartingWith">
            <summary> Function for matching the start of a type name. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveNameEndingWith">
            <summary> Function for matching the end of a type name. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveCustomAttribute">
            <summary> Function for finding classes with a particular custom attribute. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveCustomAttributeOrInherit">
            <summary> Function for finding classes decorated with a particular custom attribute or derived one</summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.Inherits">
            <summary> Function for finding classes that inherit from a particular type. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.ImplementsInterface">
            <summary> Function for finding classes that implement a particular interface. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeAbstract">
            <summary> Function for finding abstract classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeClass">
            <summary> Function for finding classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeInterface">
            <summary> Function for finding interfaces. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeGeneric">
            <summary> Function for finding types with generic parameters. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeNested">
            <summary> Function for finding nested classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeNestedPublic">
            <summary> Function for finding nested public classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeNestedPrivate">
            <summary> Function for finding nested private classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BePublic">
            <summary> Function for finding public classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeSealed">
            <summary> Function for finding sealed classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.BeImmutable">
            <summary> Function for finding immutable classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HasNullableMembers">
            <summary> Function for finding nullable classes. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.ResideInNamespace">
            <summary> Function for finding types in a particular namespace. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.ResideInNamespaceMatching">
            <summary> Function for matching a type name using a regular expression. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveDependencyOnAny">
            <summary> Function for finding types that have a dependency on any of the supplied types. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.HaveDependencyOnAll">
            <summary> Function for finding types that have a dependency on all of the supplied types. </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.OnlyHaveDependenciesOnAnyOrNone">
            <summary> Function for finding types that have a dependency on type other than one of the supplied types.</summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionDelegates.MeetCustomRule">
            <summary> Function for finding public classes. </summary>
        </member>
        <member name="T:NetArchTest.Rules.FunctionSequence">
            <summary>
            A sequence of function calls that are combined to select types.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.FunctionSequence._groups">
            <summary> Holds the groups of function calls. </summary>
        </member>
        <member name="M:NetArchTest.Rules.FunctionSequence.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.FunctionSequence"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.FunctionSequence.AddFunctionCall``1(NetArchTest.Rules.FunctionDelegates.FunctionDelegate{``0},``0,System.Boolean)">
            <summary>
            Adds a function call to the current list.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.FunctionSequence.CreateGroup">
            <summary>
            Creates a new logical grouping of function calls.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.FunctionSequence.Execute(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},System.Boolean)">
            <summary>
            Executes all the function calls that have been specified.
            </summary>
            <returns>A list of types that are selected by the predicates (or not selected if optional reversing flag is passed).</returns>
        </member>
        <member name="T:NetArchTest.Rules.FunctionSequence.FunctionCall">
            <summary>
            Represents a single function call.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.FunctionSequence.FunctionCall.#ctor(System.Delegate,System.Object,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.FunctionSequence.FunctionCall"/> class.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.FunctionSequence.FunctionCall.FunctionDelegate">
            <summary>
            A delegate for a function call.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.FunctionSequence.FunctionCall.Value">
            <summary>
            The input value for the function call.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.FunctionSequence.FunctionCall.Condition">
            <summary>
            The Condition to apply to the call - i.e. "is" or "is not".
            </summary>
        </member>
        <member name="T:NetArchTest.Rules.ICustomRule">
            <summary>
            An externally defined rule that can be applied as a condition or a predicate.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.ICustomRule.MeetsRule(Mono.Cecil.TypeDefinition)">
            <summary>
            Tests whether the supplied type meets the rule.
            </summary>
            <param name="type">The type to be tested.</param>
            <returns>The result of the test.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Policies.Policy">
            <summary>
            An aggregate of rules and results that can be used for reporting.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Policies.Policy._name">
            <summary> The simple name of the policy. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Policies.Policy._description">
            <summary> A detailed description of the policy. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.Policy.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Policies.Policy"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.Policy.Define(System.String,System.String)">
            <summary>
            Defines a policy that aggregates a set of rules together for reporting.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.Policy.For(System.Func{NetArchTest.Rules.Types})">
            <summary>
            Sets the types that the policy will apply to.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.Policy.For(NetArchTest.Rules.Types)">
            <summary>
            Sets the types that the policy will apply to.
            </summary>
        </member>
        <member name="T:NetArchTest.Rules.Policies.PolicyDefinition">
            <summary>
            An aggregate of rules and results that can be used for reporting.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Policies.PolicyDefinition._typesLocator">
            <summary> The function that defines the list of types to execute against each rule. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Policies.PolicyDefinition._tests">
            <summary> The list of tests that have been added to the policy. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyDefinition.#ctor(System.Func{NetArchTest.Rules.Types},System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Policies.PolicyDefinition"/> class.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyDefinition.Name">
            <summary>
            The simple name of the policy.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyDefinition.Description">
            <summary>
            A detailed description of the policy.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyDefinition.Add(System.Func{NetArchTest.Rules.Types,NetArchTest.Rules.ConditionList},System.String,System.String)">
            <summary>
            Adds a rule to the policy that can optionally be marked with a name and description.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyDefinition.Add(System.Func{NetArchTest.Rules.Types,NetArchTest.Rules.ConditionList})">
            <summary>
            Adds a rule to the policy that can optionally be marked with a name and description.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyDefinition.Evaluate">
            <summary>
            Evaluates all the rules that have been added to the policy against the types defined for the policy.
            </summary>
            <returns>A list of results.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Policies.PolicyResult">
            <summary>
            A single test result for a policy.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyResult.#ctor(NetArchTest.Rules.TestResult,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Policies.PolicyResult"/> class.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResult.IsSuccessful">
            <summary>
            Gets a flag indicating the success or failure of the test.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResult.FailingTypes">
            <summary>
            Gets a collection populated with a list of any types that failed the test.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResult.Name">
            <summary>
            Gets the simple name associated with the test.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResult.Description">
            <summary>
            Gets the detailed description associated with the test.
            </summary>
        </member>
        <member name="T:NetArchTest.Rules.Policies.PolicyResults">
            <summary>
            A set of results for a policy that has been executed against a list of types.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyResults.#ctor(System.Collections.Generic.IReadOnlyList{NetArchTest.Rules.Policies.PolicyResult},System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Policies.PolicyResults"/> class.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResults.HasViolations">
            <summary>
            Gets whether or not the policy has any rule violations
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResults.Results">
            <summary>
            Gets the results of each rule that was added the policy.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResults.Name">
            <summary>
            Gets the simple name associated with the policy.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyResults.Description">
            <summary>
            Gets the detailed description associated with the policy.
            </summary>
        </member>
        <member name="T:NetArchTest.Rules.Policies.PolicyTest">
            <summary>
            A single test that has been added to a policy.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Policies.PolicyTest.#ctor(System.Func{NetArchTest.Rules.Types,NetArchTest.Rules.ConditionList},System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Policies.PolicyTest"/> class.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyTest.Definition">
            <summary>
            The definition of the test expressed as a function.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyTest.Name">
            <summary>
            Gets the simple name associated with the test.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.Policies.PolicyTest.Description">
            <summary>
            Gets the detailed description associated with the test.
            </summary>
        </member>
        <member name="T:NetArchTest.Rules.PredicateList">
            <summary>
            A set of predicates and types that have have conjunctions (i.e. "and", "or") and executors (i.e. Types(), TypeDefinitions()) applied to them.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.PredicateList._types">
            <summary> A list of types that conditions can be applied to. </summary>
        </member>
        <member name="F:NetArchTest.Rules.PredicateList._sequence">
            <summary> The sequence of conditions that is applied to the type of list. </summary>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},NetArchTest.Rules.FunctionSequence)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.PredicateList"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.Should">
            <summary>
            Links a predicate defining a set of classes to a condition that tests them.
            </summary>
            <returns>A condition that tests classes against a given criteria.</returns>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.ShouldNot">
            <summary>
            Links a predicate defining a set of classes to a condition that tests them.
            </summary>
            <returns>A condition that tests classes against a given criteria.</returns>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.GetTypeDefinitions">
            <summary>
            Returns the type definitions returned by these predicate.
            </summary>
            <returns>A list of type definitions.</returns>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.GetTypes">
            <summary>
            Returns the types returned by these predicates.
            </summary>
            <returns>A list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.And">
            <summary>
            Specifies that any subsequent predicates should be treated as "and" conditions.
            </summary>
            <returns>An set of predicates that can be applied to a list of classes.</returns>
            <remarks>And() has higher priority than Or() and it is computed first.</remarks>
        </member>
        <member name="M:NetArchTest.Rules.PredicateList.Or">
            <summary>
            Specifies that any subsequent predicates should be treated as part of an "or" condition.
            </summary>
            <returns>An set of predicates that can be applied to a list of classes.</returns>
        </member>
        <member name="T:NetArchTest.Rules.Predicates">
            <summary>
            A set of predicates that can be applied to a list of types.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Predicates._types">
            <summary> A list of types that conditions can be applied to. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Predicates._sequence">
            <summary> The sequence of conditions that is applied to the type of list. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition})">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Predicates"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition},NetArchTest.Rules.FunctionSequence)">
            <summary>
            Initializes a new instance of the <see cref="T:NetArchTest.Rules.Predicates"/> class.
            </summary>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveName(System.String[])">
            <summary>
            Selects types that have a specific name.
            </summary>
            <param name="name">The name of the class to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveName(System.String[])">
            <summary>
            Selects types that do not have a particular name.
            </summary>
            <param name="name">The name of the class to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveNameMatching(System.String)">
            <summary>
            Selects types according to a regular expression matching their name.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveNameMatching(System.String)">
            <summary>
            Selects types according to a regular expression that does not match their name.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveNameStartingWith(System.String[])">
            <summary>
            Selects types whose names start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveNameStartingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveNameStartingWith(System.String[])">
            <summary>
            Selects types whose names do not start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveNameStartingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names do not start with the specified text.
            </summary>
            <param name="start">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveNameEndingWith(System.String)">
            <summary>
            Selects types whose names end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveNameEndingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveNameEndingWith(System.String)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveNameEndingWith(System.String,System.StringComparison)">
            <summary>
            Selects types whose names do not end with the specified text.
            </summary>
            <param name="end">The text to match against.</param>
            <param name="comparer">The string comparer.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveCustomAttribute(System.Type)">
            <summary>
            Selects types that are decorated with a specific custom attribute.
            </summary>
            <param name="attribute">The attribute to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveCustomAttributeOrInherit(System.Type)">
            <summary>
            Selects types that are decorated with a specific custom attribute or derived one.
            </summary>
            <param name="attribute">The base attribute to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveCustomAttribute(System.Type)">
            <summary>
            Selects types that are not decorated with a specific custom attribute.
            </summary>
            <param name="attribute">The attribute to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveCustomAttributeOrInherit(System.Type)">
            <summary>
            Selects types that are not decorated with a specific custom attribute or derived one.
            </summary>
            <param name="attribute">The base attribute to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.Inherit(System.Type)">
            <summary>
            Selects types that inherit a particular type.
            </summary>
            <param name="type">The type to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotInherit(System.Type)">
            <summary>
            Selects types that do not inherit a particular type.
            </summary>
            <param name="type">The type to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ImplementInterface(System.Type)">
            <summary>
            Selects types that implement a particular interface.
            </summary>
            <param name="interfaceType">The interface type to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotImplementInterface(System.Type)">
            <summary>
            Selects types that do not implement a particular interface.
            </summary>
            <param name="interfaceType">The interface type to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreAbstract">
            <summary>
            Selects types that are marked as abstract.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotAbstract">
            <summary>
            Selects types that are not marked as abstract.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreClasses">
            <summary>
            Selects types that are classes.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotClasses">
            <summary>
            Selects types that are not classes.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreGeneric">
            <summary>
            Selects types that have generic parameters.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotGeneric">
            <summary>
            Selects types that do not have generic parameters.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreInterfaces">
            <summary>
            Selects types that are interfaces.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotInterfaces">
            <summary>
            Selects types that are not interfaces.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNested">
            <summary>
            Selects types that are nested.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNestedPublic">
            <summary>
            Selects types that are nested and declared as public.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNestedPrivate">
            <summary>
            Selects types that are nested and declared as private.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotNested">
            <summary>
            Selects types that are not nested.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotNestedPublic">
            <summary>
            Selects types that are not nested and declared as public.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
            <remarks>NB: This method will return non-nested types and nested types that are declared as private.</remarks>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotNestedPrivate">
            <summary>
            Selects types that are not nested and declared as private.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
            <remarks>NB: This method will return non-nested types and nested types that are declared as public.</remarks>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ArePublic">
            <summary>
            Selects types that have public scope.
            </summary>
            <remarks>
            This method will only act on types that are visible to the function. Use InternalsVisibleTo if testing from a separate assembly.
            </remarks>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotPublic">
            <summary>
            Selects types that do not have public scope.
            </summary>
            <remarks>
            This method will only act on types that are visible to the function. Use InternalsVisibleTo if testing from a separate assembly.
            </remarks>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreSealed">
            <summary>
            Selects types according that are marked as sealed.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreNotSealed">
            <summary>
            Selects types according that are not marked as sealed.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreImmutable">
            <summary>
            Selects types that are immutable.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.AreMutable">
            <summary>
            Selects types that are mutable.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.OnlyHaveNullableMembers">
            <summary>
            Selects types that have only nullable members.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveSomeNonNullableMembers">
            <summary>
            Selects types that have some non-nullable members.
            </summary>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ResideInNamespace(System.String)">
            <summary>
            Selects types that reside in a particular namespace.
            </summary>
            <param name="name">The namespace to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotResideInNamespace(System.String)">
            <summary>
            Selects types that do not reside in a particular namespace.
            </summary>
            <param name="name">The namespace to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ResideInNamespaceMatching(System.String)">
            <summary>
            Selects types whose namespaces match a regular expression.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ResideInNamespaceStartingWith(System.String)">
            <summary>
            Selects types whose namespaces start with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ResideInNamespaceEndingWith(System.String)">
            <summary>
            Selects types whose namespaces end with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.ResideInNamespaceContaining(System.String)">
            <summary>
            Selects types whose namespaces contain a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotResideInNamespaceMatching(System.String)">
            <summary>
            Selects types whose namespaces do not match a regular expression.
            </summary>
            <param name="pattern">The regular expression pattern to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotResideInNamespaceStartingWith(System.String)">
            <summary>
            Selects types whose namespaces start with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotResideInNamespaceEndingWith(System.String)">
            <summary>
            Selects types whose namespaces end with a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotResideInNamespaceContaining(System.String)">
            <summary>
            Selects types whose namespaces contain a particular name part.
            </summary>
            <param name="name">The namespace part to match against.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveDependencyOn(System.String)">
            <summary>
            Selects types that have a dependency on a particular type.
            </summary>
            <param name="dependency">The dependency type to match against. This can be a namespace or a specific type.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveDependencyOnAny(System.String[])">
            <summary>
            Selects types that have a dependency on any of the supplied types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveDependencyOnAll(System.String[])">
            <summary>
            Selects types that have a dependency on all of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.OnlyHaveDependenciesOn(System.String[])">
            <summary>
            Selects types that have a dependency on any of the supplied types and cannot have any other dependency. 
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveDependencyOn(System.String)">
            <summary>
            Selects types that do not have a dependency on a particular type.
            </summary>
            <param name="dependency">The dependency type to match against. This can be a namespace or a specific type.</param>
            <returns>An updated set of predicates that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveDependencyOnAny(System.String[])">
            <summary>
            Selects types that do not have a dependency on any of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.DoNotHaveDependencyOnAll(System.String[])">
            <summary>
            Selects types that do not have a dependency on all of the particular types.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.HaveDependenciesOtherThan(System.String[])">
            <summary>
            Selects types that have a dependency other than any of the given dependencies.
            </summary>
            <param name="dependencies">The dependencies to match against. These can be namespaces or specific types.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Predicates.MeetCustomRule(NetArchTest.Rules.ICustomRule)">
            <summary>
            Selects types that meet a custom rule.
            </summary>
            <param name="rule">An instance of the custom rule.</param>
            <returns>An updated set of conditions that can be applied to a list of types.</returns>
        </member>
        <member name="T:NetArchTest.Rules.TestResult">
            <summary>
            Defines a result from a test carried out on a <see cref="T:NetArchTest.Rules.ConditionList"/>.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.TestResult._failingTypes">
            <summary> The list of types that failed the test. </summary>
        </member>
        <member name="P:NetArchTest.Rules.TestResult.IsSuccessful">
            <summary>
            Gets a flag indicating the success or failure of the test.
            </summary>
        </member>
        <member name="P:NetArchTest.Rules.TestResult.FailingTypes">
            <summary>
            Gets a list of the types that failed the test.
            </summary>
            <remarks>
            This method loads all the types and may throw dependency loading errors if the test project does not have a direct dependency on the type being loaded.
            </remarks>
        </member>
        <member name="P:NetArchTest.Rules.TestResult.FailingTypeNames">
            <summary>
            Gets a list of the type nmames that failed the test.
            </summary>
            <remarks>
            This is a "safer" way of getting a list of failed types as it does not load the types when enumerating the list. This can lead to dependency loading errors.
            </remarks>
        </member>
        <member name="M:NetArchTest.Rules.TestResult.Success">
            <summary>
            Creates a new instance of <see cref="T:NetArchTest.Rules.TestResult"/> indicating a successful test.
            </summary>
            <returns>Instance of <see cref="T:NetArchTest.Rules.TestResult"/></returns>
        </member>
        <member name="M:NetArchTest.Rules.TestResult.Failure(System.Collections.Generic.IReadOnlyList{Mono.Cecil.TypeDefinition})">
            <summary>
            Creates a new instance of <see cref="T:NetArchTest.Rules.TestResult"/> indicating a failed test.
            </summary>
            <returns>Instance of <see cref="T:NetArchTest.Rules.TestResult"/></returns>
        </member>
        <member name="T:NetArchTest.Rules.Types">
            <summary>
            Creates a list of types that can have predicates and conditions applied to it.
            </summary>
        </member>
        <member name="F:NetArchTest.Rules.Types._types">
            <summary> The list of types represented by this instance. </summary>
        </member>
        <member name="F:NetArchTest.Rules.Types._exclusionList">
            <summary> The list of namespaces to exclude from the current domain. </summary>
        </member>
        <member name="M:NetArchTest.Rules.Types.#ctor(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition})">
            <summary>
            Prevents any external class initializing a new instance of the <see cref="T:NetArchTest.Rules.Types"/> class.
            </summary>
            <param name="types">The list of types for the instance.</param>
        </member>
        <member name="M:NetArchTest.Rules.Types.InCurrentDomain">
            <summary>
            Creates a list of types based on all the assemblies in the current AppDomain
            </summary>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.InAssembly(System.Reflection.Assembly,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a list of types based on a particular assembly.
            </summary>
            <param name="assembly">The assembly to base the list on.</param>
            <param name="searchDirectories">An optional list of search directories to allow resolution of referenced assemblies.</param>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.InAssemblies(System.Collections.Generic.IEnumerable{System.Reflection.Assembly},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a list of types based on a list of assemblies.
            </summary>
            <param name="assemblies">The assemblies to base the list on.</param>
            <param name="searchDirectories">An optional list of search directories to allow resolution of referenced assemblies.</param>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.InNamespace(System.String)">
            <summary>
            Creates a list of all the types in a particular namespace.
            </summary>
            <param name="name">The namespace to list types for. This is case insensitive.</param>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.FromFile(System.String)">
            <summary>
            Creates a list of all the types in a particular module file.
            </summary>
            <param name="filename">The filename of the module. This is case insensitive.</param>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
            <remarks>Assumes that the module is in the same directory as the executing assembly.</remarks>
        </member>
        <member name="M:NetArchTest.Rules.Types.FromPath(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a list of all the types found on a particular path.
            </summary>
            <param name="path">The relative path to load types from.</param>
            <param name="searchDirectories">An optional list of search directories to allow resolution of referenced assemblies.</param>
            <returns>A list of types that can have predicates and conditions applied to it.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.GetAllTypes(System.Collections.Generic.IEnumerable{Mono.Cecil.TypeDefinition})">
            <summary>
            Recursively fetch all the nested types in a collection of types.
            </summary>
            <returns>The expanded collection of types</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.GetTypeDefinitions">
            <summary>
            Returns the list of <see cref="T:Mono.Cecil.TypeDefinition"/> objects describing the types in this list.
            </summary>
            <returns>The list of <see cref="T:Mono.Cecil.TypeDefinition"/> objects in this list.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.GetTypes">
            <summary>
            Returns the list of <see cref="T:System.Type"/> objects describing the types in this list.
            </summary>
            <returns>The list of <see cref="T:System.Type"/> objects in this list.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.That">
            <summary>
            Allows a list of types to be applied to one or more filters.
            </summary>
            <returns>A list of types onto which you can apply a series of filters.</returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.Should">
            <summary>
            Applies a set of conditions to the list of types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.ShouldNot">
            <summary>
            Applies a negative set of conditions to the list of types.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetArchTest.Rules.Types.ReadAssemblyDefinition(System.String,Mono.Cecil.ReaderParameters)">
            <summary>
            Reads the assembly, ignoring a BadImageFormatException
            </summary>
            <param name="path">The path to the exception</param>
            <param name="parameters">A set of optional parameters - normally used to specify custom assembly resolvers. </param>
            <returns>The assembly definition for the path (if it exists).</returns>
        </member>
    </members>
</doc>
